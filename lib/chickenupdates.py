"""
Library module for updating a player's farm data.
"""
from random import randint
from time import time
from typing import Union
from discord.ext.commands import Context
from db.farmdb import Farm
from db.bankdb import Bank
from db.userdb import User
from db.marketdb import Market
from resources.settings import FARM_DROP, MAX_EGG_GENERATED, CORN_PER_PLOT
from resources.tips import tips
from tools.listeners import on_user_transaction
from lib.shared import make_embed_object, format_number
from lib.chickenshared import *

async def drop_egg_for_player(farm_data: dict, hours_passed: int) -> Union[dict, int]:
        """
        Calculates the eggs generated by the farm.

        Args:
            farm_data (dict): The farm data to calculate the eggs for.
            hours_passed (int): The hours passed.

        Returns:
            Union[dict, int]
        """
        total_profit, farm_data = await give_total_farm_profit(farm_data.copy(), hours_passed)
        if total_profit > 0:
            farm_data['eggs_generated'] += min(total_profit, MAX_EGG_GENERATED)
        return farm_data, total_profit
                    
async def feed_eggs_auto(farm_data: dict, bank_amount: int) -> int:
    """
    Feeds the chickens automatically.

    Args:
        farm_data (dict): The farm data to feed the chickens for.
        bank_amount (int): The bank amount to feed the chickens with.

    Returns:
        int
    """
    total_upkeep = 0

    if farm_data['farmer'] == "Sustainable Farmer":
        random_range = load_farmer_upgrades('Sustainable Farmer')[1]
        for chicken in farm_data['chickens']:
            if chicken['happiness'] == 100:
                continue
            generated_happiness = randint(random_range[0], random_range[1])
            cHappiness = chicken['happiness'] + generated_happiness
            if cHappiness > 100:
                cHappiness = 100
            chicken['happiness'] = cHappiness
            chicken_cost = int(await get_chicken_egg_value(chicken) * chicken['upkeep_multiplier'])
            total_upkeep += chicken_cost

        if bank_amount < total_upkeep:
            return 0
        
        return total_upkeep

async def update_user_farm(ctx: Context, user: discord.Member, data: dict) -> tuple[dict, int]:
    """
    Updates the user's farm.

    Args:
        ctx (Context): The context of the command.
        user (discord.Member): The user to update the farm for.
        data (dict): The data to update the farm from.

    Returns:
        Union[dict, None]
    """
    if not data['farm_data']:
        return None, 0
    
    farm_data = data['farm_data']

    if len(farm_data['chickens']) == 0:
        return farm_data, 0
    
    last_drop_time = time() - farm_data['last_chicken_drop']
    updated_farm_data = farm_data
    hours_passed_since_last_egg_drop = min((last_drop_time // FARM_DROP), 24)
    hours_passed_since_last_egg_drop = int(hours_passed_since_last_egg_drop)
    total_profit = 0

    if hours_passed_since_last_egg_drop != 0:
        user_data = data['user_data']
        updated_farm_data, total_money_earned_without_tax = await drop_egg_for_player(farm_data, hours_passed_since_last_egg_drop)
        farm_data = updated_farm_data
        taxes = await farm_maintence_tax(farm_data, hours_passed_since_last_egg_drop)
        total_profit = await update_user_points(ctx, user_data, data['bank_data'], updated_farm_data, taxes, total_money_earned_without_tax)
        await Farm.update_chicken_drop(user.id)
        await Farm.update(user.id, chickens=updated_farm_data['chickens'], eggs_generated=updated_farm_data['eggs_generated'])

    return updated_farm_data, total_profit

async def update_farmer(user: discord.Member, data: dict) -> None:
    """
    Feeds the chickens automatically for the sustainable farmer.

    Args:
        user (discord.Member): The user to update the farmer for.
        data (dict): The data to update the farmer from.

    Returns:
        None
    """
    farm_data = data['farm_data']
    last_drop_time = time() - farm_data['last_farmer_drop']
    hours_passed_since_feed = 0
    bank_data = data['bank_data']
    bank_amount = bank_data['bank']
    if farm_data['farmer'] == "Sustainable Farmer":
        hours_passed_since_feed = min(last_drop_time // load_farmer_upgrades('Sustainable Farmer')[0], 2)
        for _ in range(int(hours_passed_since_feed)):
            total_upkeep = await feed_eggs_auto(farm_data, bank_amount)
            bank_amount -= total_upkeep
            if total_upkeep == 0:
                break
            if bank_amount < total_upkeep:
                break
        if hours_passed_since_feed != 0:
            await Bank.update(farm_data['user_id'], bank_amount)
            await Farm.update(farm_data['user_id'], chickens=farm_data['chickens'], eggs_generated=farm_data['eggs_generated'])
            await Farm.update_farmer_drop(user.id)

async def get_usr_farm(ctx: Context, user: discord.Member, data) -> discord.Embed:
        """
        Gets the user's farm, updates the farmer and retrieves chuckens from the market.

        Args:
            ctx (Context): The context of the command.
            user (discord.Member): The user to get the farm for.
            data (dict): The data to get the farm from.

        Returns:
            discord.Embed
        """
        farm_data = data['farm_data']
        
        if farm_data:

            farm_data = await get_player_chicken_from_market(ctx, user, data)

            if len(farm_data['chickens']) == 0:
                return

            if farm_data['farmer'] == 'Sustainable Farmer':
                await update_farmer(user, data)

            msg = await make_embed_object(
                title=
                f":chicken: {farm_data['farm_name']}\n:egg: **Eggs generated**: {await format_number(farm_data['eggs_generated'])}\n:farmer: Farmer: {farm_data['farmer'] if farm_data['farmer'] else 'No Farmer.'}",
                description="\n".join([
                f"{get_rarity_emoji(chicken['rarity'])}  **{index + 1}.** **{chicken['rarity']} {chicken['name']}** \n:partying_face: Happiness: **{chicken['happiness']}%**\n :gem: Upkeep rarity: **{determine_upkeep_rarity_text(chicken['upkeep_multiplier'])}**\n"
                for index, chicken in enumerate(farm_data['chickens'])
            ]))
            msg.set_thumbnail(url=user.display_avatar)
            msg.set_footer(text=tips[randint(0, len(tips) - 1)])
            return msg
        else:
            return None
 
async def update_player_corn(user: discord.Member, data: dict) -> int:
    """
    Updates the player's corn.

    Args:
        user (discord.Member): The user to update the corn for.
        data (dict): The data to update the corn from.

    Returns:
        int
    """
    if not data:
        return 0
    
    farm_data = data
    last_drop_time = time() - farm_data['last_corn_drop']
    hours_passed_since_last_drop = min(last_drop_time // FARM_DROP, 24)
    corn_produced = 0
    current_corn = farm_data['corn']
    if hours_passed_since_last_drop != 0:
        corn_produced = await calculate_corn(farm_data, hours_passed_since_last_drop)
        current_corn += corn_produced
        current_corn = min(current_corn, farm_data['corn_limit'])
        await Farm.update_corn_drop(user.id)
        await Farm.update(user.id, corn=current_corn)
    return current_corn, corn_produced

async def calculate_corn(farm_data: dict, hours_passed: int) -> int:
    """
    Calculates the corn generated by the farm.

    Args:
        farm_data (dict): The farm data to calculate the corn for.
        hours_passed (int): The hours passed.

    Returns:
        int
    """
    corn_produced = farm_data['plot'] * CORN_PER_PLOT   
    corn_produced *= hours_passed
    if farm_data['farmer'] == 'Rich Farmer':
        corn_produced += corn_produced * load_farmer_upgrades('Rich Farmer')[1] / 100
    corn_produced = int(corn_produced)
    return corn_produced

async def update_user_points(ctx: Context, user_data: dict, bank_data: dict, farm_data: dict, taxes: int, total_profit: int) -> int:
    """
    Updates the user's points after the farm has been calculated.

    Args:
        ctx (Context): The context of the command.
        user_data (dict): The user data to update the points for.
        bank_data (dict): The bank data to update the points for.
        farm_data (dict): The farm data to update the points for.
        taxes (int): The taxes to pay.
        total_profit (int): The total profit.

    Returns:
        int
    """
    user_data['points'] += total_profit
    profit_with_taxes = total_profit - taxes

    if user_data['points'] >= taxes:
        user_data['points'] -= taxes
        await User.update_points(user_data['user_id'], user_data['points'])
    elif bank_data['bank'] >= taxes:
        bank_data['bank'] -= taxes
        await Bank.update(user_data['user_id'], bank_data['bank'])
    elif user_data['points'] + bank_data['bank'] >= taxes:
        difference = taxes - user_data['points']
        user_data['points'] = 0
        bank_data['bank'] -= difference
        await Bank.update(user_data['user_id'], bank_data['bank'])
        await User.update_points(user_data['user_id'], user_data['points'])
    else:
        debt = taxes - user_data['points'] - bank_data['bank']
        money_earned = await quick_sell_chicken(ctx, farm_data, debt)
        await User.update_points(user_data['user_id'], user_data['points'] + money_earned)
        return 0
     
    await on_user_transaction(ctx, profit_with_taxes, 0 if profit_with_taxes > 0 else 1)
    return profit_with_taxes

async def give_total_farm_profit(farm_data_copy: dict, hours_passed: int) -> int:
    """
    Gives the total farm profit.

    Args:
        farm_data_copy (dict): The copy of a farm data to give the profit for.
        hours_passed (int): The hours passed.

    Returns:
        int
    """
    total_profit = 0
    for chicken in farm_data_copy['chickens']:

        if chicken['rarity'] == 'DEAD':
            continue

        egg_value = await get_chicken_egg_value(chicken)
        chicken_loss = int(egg_value * chicken['upkeep_multiplier'])
        chicken_profit = egg_value - chicken_loss
        total_profit += ((chicken_profit * chicken['happiness']) * hours_passed) // 100
        chicken['eggs_generated'] += chicken_profit
        chicken = await decrease_chicken_happiness(chicken, hours_passed)

        if chicken['happiness'] == 0:
            await devolve_chicken(chicken)

    if farm_data_copy['farmer'] == 'Rich Farmer':
        to_increase = (total_profit * load_farmer_upgrades('Rich Farmer')[0]) // 100
        total_profit += to_increase

    return total_profit, farm_data_copy

async def chicken_retriever_handler(ctx: Context, user: discord.Member, farm_data: dict, offers_list: list) -> None:
    """
    Retrieves the player's chickens from market offers if they are expired.

    Args:
        ctx (Context): The context of the command.
        user (discord.Member): The user to get the chickens for.
        farm_data (dict): The farm data to get the chickens for.
        offers_list (list): The offers list to get the chickens from.

    Returns:
        None
    """
    offers_to_process = offers_list.copy()
    chickens_added = []
    for offer in offers_to_process:
        chicken = offer['chicken']
        var = farm_data['chickens'] + [chicken]
        if len(var) > get_max_chicken_limit(farm_data):
            break
        farm_data['chickens'] = var
        offers_list.remove(offer)
        chickens_added.append(chicken)
        await Market.delete(offer['offer_id'])
    if chickens_added:
        chicken_desc = "\n\n".join([f" {get_rarity_emoji(chicken['rarity'])} **{chicken['rarity']} {chicken['name']}**" for chicken in chickens_added])
        await send_bot_embed(ctx, description=f":white_check_mark: {user.display_name}, you have successfully added the following chickens to your farm: \n\n{chicken_desc}\n Those chickens have been removed from the market.")
        await Farm.update(user.id, chickens=farm_data['chickens'])
    if offers_list:
        chicken_desc = "\n\n".join([f" {get_rarity_emoji(chicken['rarity'])} **{chicken['rarity']} {chicken['name']}**" for offer in offers_list for chicken in [offer['chicken']]])
        await send_bot_embed(ctx, description=f":no_entry_sign: {user.display_name}, you can't add the following chickens to your farm: \n\n{chicken_desc}\n They have been automatically put back in the market.")

async def get_player_chicken_from_market(ctx: Context, user: discord.Member, data):
    """
     Retrieves the player's chickens from market offers.

    Args:
        ctx (Context): The context of the command.
        user (discord.Member): The user to get the chickens for.
        data (dict): The data to get the chickens from.

    Returns:
        dict
    """
    farm_data = data['farm_data']
    market_data = await Market.get_user_offers(user.id)
    offers_list = []

    if not market_data:
        return farm_data
    for offer in market_data:
        last_offer_time = time() - offer['created_at']
        if last_offer_time // 3600 > OFFER_EXPIRE_TIME:
                offers_list.append(offer)
    if offers_list:
        await chicken_retriever_handler(ctx, user, farm_data, offers_list)

    return farm_data